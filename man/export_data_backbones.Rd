% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/export_data_backbones.R
\name{export_data_backbones}
\alias{export_data_backbones}
\title{Export Parsed GBIF Data Results with Taxonomic Backbone}
\usage{
export_data_backbones(
  occ_digital_voucher_file = "",
  occ_digital_voucher = NA,
  merge_unusable_data = FALSE,
  fields_to_merge = c("Ctrl_fieldNotes", "Ctrl_year", "Ctrl_stateProvince",
    "Ctrl_municipality", "Ctrl_locality", "Ctrl_countryCode", "Ctrl_eventDate",
    "Ctrl_habitat", "Ctrl_level0Name", "Ctrl_level1Name", "Ctrl_level2Name",
    "Ctrl_level3Name"),
  fields_to_compare = c("Ctrl_gbifID", "Ctrl_scientificName", "Ctrl_recordedBy",
    "Ctrl_recordNumber", "Ctrl_identifiedBy", "Ctrl_dateIdentified",
    "Ctrl_institutionCode", "Ctrl_collectionCode", "Ctrl_datasetName",
    "Ctrl_datasetName", "Ctrl_language", "backbone_plant_name_id", "backbone_taxon_rank",
    "backbone_taxon_status", "backbone_family", "backbone_taxon_name",
    "backbone_taxon_authors", "backbone_reviewed", "backbone_searchNotes"),
  fields_to_parse = c("Ctrl_gbifID", "Ctrl_bibliographicCitation", "Ctrl_language",
    "Ctrl_institutionCode", "Ctrl_collectionCode", "Ctrl_datasetName",
    "Ctrl_basisOfRecord", "Ctrl_catalogNumber", "Ctrl_recordNumber", "Ctrl_recordedBy",
    "Ctrl_occurrenceStatus", "Ctrl_eventDate", "Ctrl_year", "Ctrl_month", "Ctrl_day",
    "Ctrl_habitat", "Ctrl_fieldNotes", "Ctrl_eventRemarks", "Ctrl_countryCode",
    "Ctrl_stateProvince", "Ctrl_municipality", "Ctrl_county", "Ctrl_locality",
    "Ctrl_issue", "Ctrl_level0Name", "Ctrl_level1Name", "Ctrl_level2Name", 
    
    "Ctrl_level3Name", "Ctrl_identifiedBy", "Ctrl_dateIdentified", "Ctrl_scientificName",
    "Ctrl_taxonRank", "Ctrl_decimalLatitude", "Ctrl_decimalLongitude",
    "Ctrl_nameRecordedBy_Standard", "Ctrl_recordNumber_Standard",
    "Ctrl_key_family_recordedBy_recordNumber", "Ctrl_geospatial_quality",
    "Ctrl_verbatim_quality", "Ctrl_moreInformativeRecord",
    "Ctrl_coordinates_validated_by_gbif_issue", "backbone_plant_name_id",
    "backbone_taxon_rank", "backbone_taxon_status", "backbone_family",
    "backbone_taxon_name", 
     "backbone_taxon_authors", "backbone_reviewed",
    "backbone_searchedName", "backbone_searchNotes", "parseGBIF_digital_voucher",
    "parseGBIF_duplicates", "parseGBIF_num_duplicates",
    "parseGBIF_non_groupable_duplicates", "parseGBIF_duplicates_grouping_status",
    "parseGBIF_unidentified_sample", "parseGBIF_sample_taxon_name",
    "parseGBIF_sample_taxon_name_status", "parseGBIF_number_taxon_names",
    "parseGBIF_useful_for_spatial_analysis", "parseGBIF_decimalLatitude",
    "parseGBIF_decimalLongitude", "parseGBIF_backbone_plant_name_id", 
    
    "parseGBIF_backbone_taxon_rank", "parseGBIF_backbone_taxon_status",
    "parseGBIF_backbone_family", "parseGBIF_backbone_taxon_name",
    "parseGBIF_backbone_taxon_authors", "parseGBIF_backbone_reviewed",
    "parseGBIF_dataset_result"),
  silence = TRUE
)
}
\arguments{
\item{occ_digital_voucher_file}{Character. Path to CSV file result from \code{select_digital_voucher()$occ_digital_voucher}.}

\item{occ_digital_voucher}{Data frame. Result from \code{select_digital_voucher()$occ_digital_voucher}.}

\item{merge_unusable_data}{Logical. If \code{TRUE}, includes incomplete unique collection events in merge processing.
Default is \code{FALSE}.}

\item{fields_to_merge}{Character vector. Fields to merge from duplicates. Default includes:
\code{Ctrl_fieldNotes}, \code{Ctrl_year}, \code{Ctrl_stateProvince}, \code{Ctrl_municipality},
\code{Ctrl_locality}, \code{Ctrl_countryCode}, \code{Ctrl_eventDate}, \code{Ctrl_habitat},
\code{Ctrl_level0Name}, \code{Ctrl_level1Name}, \code{Ctrl_level2Name}, \code{Ctrl_level3Name}.}

\item{fields_to_compare}{Character vector. Fields to compare content frequency across duplicates.
Includes backbone taxonomic fields.}

\item{fields_to_parse}{Character vector. All fields to include in output, including backbone taxonomy.}

\item{silence}{Logical. If \code{TRUE}, does not display progress messages. Default is \code{TRUE}.}
}
\value{
A list with 6 data frames:
\itemize{
\item \code{all_data}: All processed records (merged unique collection events and duplicates)
\item \code{useable_data_merge}: Merged complete unique collection events
\item \code{useable_data_raw}: Raw complete unique collection events
\item \code{duplicates}: Duplicates of unique collection events
\item \code{unusable_data_merge}: Merged incomplete unique collection events (NA if merge_unusable_data=FALSE)
\item \code{unusable_data_raw}: Raw incomplete unique collection events
}
}
\description{
Processes and exports results from parsed GBIF occurrence data using taxonomic backbone,
merging information from duplicate records to create unique collection event records.
For each unique collection event key (complete or incomplete), this function combines
information from duplicate records and generates a single unique collection event record.
}
\details{
This function is a variant of \code{export_data()} that uses taxonomic backbone data
instead of WCVP for taxonomic resolution. The processing logic remains the same:
\subsection{Taxonomic Identification Selection:}{

For complete unique collection event keys, the accepted taxon name is selected as:
\enumerate{
\item The most frequently applied name at or below species rank among duplicates
\item If equal frequency, uses alphabetical order
\item If no species-level identification, marked as unidentified
}
}

\subsection{Output Datasets:}{
\itemize{
\item \strong{useable_data}: Unique collection events with taxonomic identification and coordinates
\item \strong{unusable_data}: Unique collection events without identification and/or coordinates
\item \strong{duplicates}: All duplicate records of unique collection events
}
}
}
\seealso{
\code{\link[=export_data]{export_data()}} for the WCVP-based version,
\code{\link[=select_digital_voucher]{select_digital_voucher()}} for selecting digital vouchers,
\code{\link[=batch_checkName_backbone]{batch_checkName_backbone()}} for taxonomic name checking with backbone
}
\author{
Pablo Hendrigo Alves de Melo,
Nadia Bystriakova &
Alexandre Monro
}
